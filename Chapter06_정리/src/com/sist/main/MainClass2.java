package com.sist.main;

/*
 * 	객체 지향 프로그램
 * 		Application. Web Application => 캡슐화, 인터페이스 => 연산자, 제어문, 반복문 => 데이터베이스 연동
 * 
 * 	클래스 구성 : 공통적인 데이터, 기능을 모아서 저장 => 사용
 * 	=> 추상화(사물 단순화) => 구체화
 * 		= 멤버변수
 * 		= 메소드
 * 
 * 	=> 1개의 클래스로 동작하는 것이 아님
 * 		여러 개의 클래스를 연관 관계
 * 		행위자 <=> 처리
 * 		사람		자판기
 * 		사용자,	 웹
 * 		관리자
 * 	
 * 	설계에 필요한 데이터 설계(벤치마킹) => 멤버 변수
 * 	기능(메뉴, 버튼) => 메소드 => 멤버 메소드
 * 	변수 => 초기화 => 생성자
 *
 *	클래스를 메모리에 저장
 *	클래스명 변수명 = new 클래스명()
 *	*** 모든 클래스는 생성자를 가지고 있음
 *
 *	재사용 / 데이터 변질, 손실 / 변경이 쉬움...(객체 지향) => 유지 보수
 *	상속, 포함 / 캡슐화 / 다형성(오버라이딩, 오버로딩)
 *
 *	*** 멤버변수
 *			따로 사용 : 인스턴스 변수
 *			1개 사용 : 정적 변수
 *		=> 데이터베이스(정규화)
 *
 *	----------------------------------------
 *	클래스의 구성 요소
 *		class A
 *		{
 *			- 데이터 선언 => 데이터의 손실, 변질 방지 => 은닉화
 *						private
 *				· 멤버변수 : new 이용할 때마다 따로 저장되는 공간을 만들어서 사용
 *				· 정적변수 : 1개만 생성 => 공유(static)
 *				=> private 데이터형 변수명;
 *					=> 읽기/쓰기
 *					=> 은닉화 VS 캡슐화
 *					=> 정적변수 VS 인스턴스변수 사용처 비교
 *			
 *			- 데이터 초기화
 *				· 생성자
 *					특징
 *					= 클래스명과 동일
 *					= 리턴형이 없음
 *					= 여러 개 사용 가능(오버로딩)
 *					*** 오버로딩(기능 추가)
 *						메소드명 동일
 *						매개변수의 개수나 데이터형이 다름
 *						리턴형은 관계 없음
 *					*** 생성자는 필요 시에만 사용
 *						생성자가 없는 경우에는 자동 디폴트 생성자 생성
 *					
 *					역할
 *					= 멤버변수에 초기화
 *					= 메모리 저장 시에 호출되는 메소드
 *					
 *				· 초기화 블록 : 컴파일러에 의해 자동 호출
 *					= 인스턴스 블록
 *						{
 *							멤버변수(생성자), 정적변수, 멤버메소드, 정적메소드 => 초기화
 *							=> 생성자를 반드시 호출
 *						}
 *					= 정적 블록
 *						static
 *						{
 *							정적변수만 초기화가 가능(static)
 *							=> 자동 초기화
 *						}
 *
 *			- 데이터 활용
 *				· 메소드
 *					종류
 *					= *** (일반)멤버 메소드
 *						[접근지정어] 리턴형 메소드(매개변수)
 *						{
 *							기능
 *						}
 *
 *					= 정적 메소드 => 암호화/복호화
 *						[접근지정어] static 리턴형 메소드(매개변수)
 *						{
 *							멤버 변수를 활용하지 않는 경우(공통으로 적용하는 기능)
 *						}
 *						=> 윈도우 : 모든 클래스에서 적용 => 이미지 크기 조절
 *						=> 웹 : 한글 변환 => ISO-8859_1(ASC) => UTF-8
 *							
 *					= 종단 메소드 : 오버라이딩이 안 되는 메소드
 *						[접근지정어] final 리턴형 메소드(매개변수)
 *						{
 *							확장 및 변경이 불가 => 사용 빈도 거의 없음
 *						}
 *					
 *					= 추상 메소드 : 구현이 아닌 선언만 되는 메소드 => 설계용
 *						=> 추상 클래스, 인터페이스
 *						=> 여러 개의 클래스를 1개의 이름으로 묶어서 처리
 *						=> 여러 개의 데이터 묶음을 1개의 이름으로 제어 => 배열
 *						=> 여러 개의 클래스 묶음을 1개의 이름으로 제어 => 인터페이스
 *						*** 인터페이스는 결합성을 낮게 만듦(결합성은 낮게 응집성은 높게)
 *							=> 클래스 수정 시 다른 클래스에 영향을 얼마나 미치는가(결합성)
 *		}
 *	객체지향 3대 특성
 *		- 캡슐화 : private 변수 => 읽기/쓰기 메소드
 *		- 상속 : extends(확장) => 기존의 기능을 사용
 *				=> static, 생성자, 초기화 블록, private는 접근 불가
 *				=> final 클래스는 상속 불가
 *		- 다형성 : 변경/추가 => 오버라이딩/오버로딩
 *		- 재사용 : 변경(상속), 있는 그대로 사용(포함)
 *				=> 멤버변수로 사용 => 기본형, 배열, 클래스, 열거형, 인터페이스(데이터베이스 연결)
 *	클래스의 종류
 *		- 추상 클래스
 *			public abstract class ClassName
 *			{
 *			}
 *		- 인터페이스(추상클래스의 일종)
 *			public interface interface명
 *			{
 *				상수형 변수
 *				선언만된 메소드 => 윈도우 : 버튼, 마우스, 키보드 
 *			}
 *		=> 미완성된 클래스
 *			= new를 이용해서 메모리 할당
 *			= 상속 내려서 구현된 다음 사용
 *		- 내부 클래스 : 
 *		- 멤버 클래스
 *			class A => 네트워크 서버 => 접속 시 처리 => 윈도우
 *			{
 *				데이터 => 접속자 IP 저장
 *				class B => 통신 서버 => 접속 없이 통신 => 쓰레드
 *				{
 *					데이터
 *				}
 *			}
 *		- 익명의 클래스
 *			class A
 *			{
 *				B b=new B()
 *				{
 *					void display() // 오버라이딩
 *					{
 *					}
 *				}
 *			}
 *			class B
 *			{
 *				void display()
 *				{
 *				}
 *			}
 *		
 *	사전에 에러 방지(예외 처리)
 *		- 직접 처리
 *			try ~ catch
 *		- 간접 처리
 *			메소드() throws 예외 처리
 *		- 임의 발생 => 테스트
 *		- 사용자 정의 예외 처리			
 *	--------------------> 기본 문법
 *	라이브러리 => 조립
 *		- String, IO, Collection => SQL => Network
 *
 */

import java.util.*;
import javax.swing.*;
import javax.swing.table.*;
import java.awt.*;

// 오버라이딩 => 기본(상속) => 속도(상속(X)) => 익명의 클래스를 이용하면 재정의
public class MainClass2 extends JFrame {

	// 포함 클래스
	JTable table; // 모양
	DefaultTableModel model; // 테이블 데이터 제어
	// 초기화
	public MainClass2()
	{
		String[] col= {"번호","이름","성별","주소","전화"};
		String[][] row=new String[0][5];
		model=new DefaultTableModel(row, col)
		{

			@Override
			public boolean isCellEditable(int row, int column) {
				// TODO Auto-generated method stub
//				return super.isCellEditable(row, column);
				return false; // 편집 불가 상태로 설정
			}
			
		};
		table=new JTable(model);
		JScrollPane js=new JScrollPane(table);
		
		// 배치
		add("Center", js);
		String[] data={"1","홍길동","남자","서울","010-1234-1234"};
		for(int i=0; i<10; i++)
		{
			model.addRow(data);
		}
		setSize(640, 480);
		setVisible(true);
	}
	public static void main(String[] args) {
		// TODO Auto-generated method stub

		new MainClass2();
	}

}
