package com.sist.main;

/*
 * 	1. 객체 지향 프로그램
 * 		1) 생성 목적
 * 			- 재사용 가능
 * 				· 상속 : 기본의 클래스를 변경해서 사용할 목적
 * 					예) class GenieMusic
 * 						class Melon extends GenieMusic();
 * 				· 포함 : 기존의 클래스를 그대로 사용(변경하지 않음)
 * 					예) class Melon
 * 						{
 * 							GenieMusic gm=new GenieMusic();
 * 						}
 * 			- 필요한 데이터 보호(캡슐화)
 * 				· 접근 지정어
 * 					private : 클래스에서 사용하는 멤버변수를 은닉화시킨 후 메소드를 통해 기능을 제작해서 사용
 * 								=> 읽기(getter) / 쓰기(setter)
 * 			- 수정 / 추가 가능(다형성)
 * 				· 오버라이딩 : 수정
 * 				· 오버로딩 : 추가
 * 				* 목적 : 개발(보통 1년)/유지보수(보통 10~15년)가 편리 => 가독성(누구나 쉽게 변경 가능)
 * 
 * 	2. 클래스 생성 과정
 * 		1) 클래스 구성 요소
 * 			class MainClass
 * 			{
 * 				- 변수 : 1개의 데이터를 저장
 * 					· 인스턴스 변수 : 여러 개를 따로 저장(new)하여 사용 가능
 * 						=> 중심
 * 					· 공유 변수, 클래스 변수 : static
 * 						=> 컴파일러에 의해 자동으로 메모리 1개만 생성 => 데이터 목록
 * 					예) // 자동 초기화
 * 						*** 클래스(반드시 메모리 주소를 갖는다)인 경우 : null(메모리 주소가 지정이 안 된 경우)
 * 
 * 						String name; => null
 * 						int age; => 0
 * 						String address; => null
 * 						String phone; => null
 * 						double height; => 0.0
 * 						char c; => '\0'
 * 						boolean b; => false => 1번을 메모리에 저장 => 필요한 값으로 변경해서 사용
 * 						
 * 						=> 권장 : 낱개 단위로 한 줄씩 선언
 * 							예) 권장하지 않음 : String name, address, phone...
 * 						*** 데이터(변수)는 반드시 외부에서 접근, 변경, 손실
 * 							=> private => 모든 변수
 * 				------------------------------------------------------------
 * 				- 생성자 => 접근 가능 => public
 * 						=> 무조건 생성하는 것이 아님
 * 						*** 클래스에는 반드시 생성자가 있어야 함 => 생성자가 없는 경우 컴파일러가 자동으로 생성(매개 변수가 없는 생성자 : default 생성자)
 * 						예)
 * 							class A
 * 							{
 * 								자동 생성 => A(){}
 * 							}
 * 							
 * 							class A
 * 							{
 * 								A(int a){} => 생성자가 존재 => 자동 추가 불가
 * 							}
 * 							*** 컴파일러가 자동 생성
 * 								① import : import java.lang.*; => String, System, Math
 * 								② void method()
 * 									{
 * 										return; => 생략하는 경우 => 자동으로 추가
 * 									}
 * 								③ 자바의 모든 클래스는 Object 클래스 상속
 * 									예) class A extends Object => Object에서 지원하는 모든 메소드 사용 가능
 * 								④ 생성자가 없는 경우 => 자동으로 default 생성자 추가
 * 								⑤ 자바의 모든 클래스는 예외 처리를 가짐
 * 									= 컴파일 시 : javac
 * 									= 런타임 신 : java
 * 						*** 역할
 * 							= 멤버 변수에 대한 초기화 담당
 * 							= 메모리에 저장 시 반드시 호출되는 메소드
 * 							=> 생성자 호출 시 new 생성자()
 * 							=> 모든 클래스는 생성자가 1개 이상 존재(없는 경우 자동 추가)
 * 						*** 특징
 * 							= 생성자 이름은 반드시 클래스명과 동일
 * 							= 리턴형이 없음(void는 리턴형임)
 * 								class A => int A(), void A() => 일반 메소드
 * 							= 생성자는 다른 클래스에서 메모리 할당 후에 사용 => 기본 public
 * 							= 필요 시에 여러 개의 생성자 생성 가능 => 같은 이름으로 여러 개를 생성하여 다른 기능 수행 => 오버로딩(중복함수정의)
 * 							*** 오버로딩
 * 								① 조건
 * 									= 메소드명이 동일
 * 									= 매개변수의 개수나 데이터형이 다름
 * 									= 리턴형은 관계 없음
 * 										예) int aaa() => aaa() // 같은 함수
 * 											void aaa() => aaa() // 같은 함수
 * 											void aaa(int a) => aaa(int) // 다른 함수
 * 											void aaa(int b) => aaa(int)
 * 									= 같은 클래스에서 제작
 * 									= 생성자, 멤버 메소드에서도 적용
 * 										예) println(), println(String s)...
 * 											substring(int s) substring(int s, int e)
 * 						*** 사용처
 * 							= 인스턴스 변수가 명시적인 초기화(파일 읽기, 데이터베이스 데이터, 크롤링)가 안 되는 경우
 * 							= 시작과 동시에 처리하는 명령문 : 서버(서버 동작), 클라이언트(데이터베이스 연결)
 * 								예) 자동 로그인, 아이디 저장, 윈도우 화면 디자인
 * 								A a=new A();
 * 									a.메소드명()
 * 								A a;
 * 									a.메소드명() => Error
 * 									
 * 				- 초기화 블록 : 생성자 없이 멤버 변수 초기화 => 컴파일러에 의해 자동 호출
 * 					· 인스턴스 블록 : 생성자를 주로 사용
 * 					예)
 * 						class A
 * 						{
 * 							int a;
 * 							{
 * 								a=(int)(Math.random()*100)+1;
 * 							}
 * 						}
 * 
 * 						A()
 * 						{
 * 							a=(int)(Math.random()*100)+1;
 * 						}
 * 					· static 블록 : 자동으로 메모리가 할당 => 생성자를 사용하지 않아도 됨
 * 					class A
 * 					{
 * 						static int a; // 생성자 호출없이 사용 가능
 * 						static
 * 						{
 * 							a=100;
 * 						}
 * 					}
 * 					A aa=new A(); => aa.a
 * 					A.a
 * 					*** 주의점
 * 						① 인스턴스 블록
 * 						② static 블록
 * 						예) class A
 * 							{
 * 								int a;
 * 								static int b;
 * 
 * 								// 1)
 * 								{ 
 * 									a=100;
 * 									b=200;
 * 								} => static
 * 
 * 								// 2)
 * 								static
 * 								{ 
 * 									a=1000; => Error
 * 									b=2000; static인 경우에만 사용 가능
 * 								}	
 * 
 * 							}
 * 							*** 초기값에 대한 호출 순서
 * 								① 명시적인 초기화
 * 									예) int a=10; => 우선시
 * 								② 초기화 블록
 * 									예) a=100;
 * 								③ 생성자 	
 * 									예) a=200;
 * 							*** 변수 => 반드시 초기화 해서 사용
 * 								= 멤버 변수
 * 								= static 변수
 * 								= 지역 변수				
 * 				------------------------------------------------------------
 * 				- 메소드 => 다른 클래스와 통신 => public
 * 					· 형식
 * 						멤버 메소드
 * 							public 리턴형 메소드명(매개변수목록) => 선언부
 * 							{	
 * 								구현부 => static 메소드나 static 변수 사용 가능
 * 									 => 인스턴스는 변수, 메소드 다 사용 가능
 * 							}
 * 							=> 호출 : 객체명.메소드()
 * 								예) Scanner scan=new Scanner(System.in);
 * 									scan.nextInt(); 
 * 						static 메소드
 * 							public static 리턴형 메소드명(매개변수목록) => 선언부
 * 							{
 * 								구현부 => static 메소드나 static 변수만 사용 가능
 * 									 => 인스턴스는 사용이 불가
 * 									*** 사용할 경우 반드시 객체 생성 후 사용
 * 							}
 * 							=> 호출 : 클래스명.메소드()
 * 								예) Math.random();
 * 
 * 							예)
 * 								String s="";
 * 								s.substring()
 * 								s.trim()
 * 								s.replace()
 * 								
 * 								String.valueOf() => static 메소드
 * 								Calendar c=Calendar.getInstance()
 * 								
 * 								*** 추상클래스와 인터페이스는 new를 사용하지 않음
 * 					· 메소드(접근지정어 public) => 다른 클래스와 연결
 * 						리턴형
 * 							= 사용자 요청에 대한 처리 결과값(1개만 사용 가능)
 * 							= 기본형
 * 								정수 => int, long
 * 								실수 => double
 * 								문자 => char
 * 								논리 => boolean
 * 							= 참조형
 * 								배열 => int[]
 * 								클래스 => A
 * 							= 리턴형
 * 							{
 * 								return 값
 * 							}
 * 							*** 결과값이 없는 경우 void 사용 => void인 경우 return 생략 가능
 * 							*** 리턴형이 있는 경우 => 반드시 받아서 저장
 * 								예) int aaa() => int a=aaa();
 * 							*** 메소드 호출 시
 * 								메소드의 return까지 수행 => 호출된 위치로 돌아옴
 * 						메소드명
 * 							= 변수 명칭법과 동일(식별자)
 * 							= 길이의 제한은 없음 => 가급적이면 압축(5~12자)
 * 							= 약속 => 소문자로 시작
 * 								  => 영문 사용(소프트웨어 이행)
 * 						매개변수
 * 							= 사용자 요청 값 => 로그인(id, pwd, check)
 * 							= 사용자의 입력, 마우스 클릭, 키보드 이용 => 매개변수로 처리
 * 							= 매개변수의 개수 제한은 없으나 가급적이면 적게 사용(3개 이하) => 3개 이상인 경우 모아서 전송 : 배열/클래스
 * 							= 매개변수는 메모리 할당 => 메소드 호출 시마다 메모리 생성
 * 							= 매개변수는 지역변수의 일종 => 메소드 종료 시 자동으로 사라짐
 * 								=> 자동 해제(메모리에서 자동 처리)
 * 								=> 초기값을 부여하는 경우
 * 									메소드 호출 시에 초기화를 해줌
 * 									예) public void disp(int a)
 * 										{
 * 											
 * 										}
 * 
 * 										disp(10) => 매개변수의 값을 설정
 * 								*** 클래스도 데이터형임 => 상속이 있는 과정에서만 형변환이 가능
 * 							
 * 			}
 * 
 * 			*** 코드 영역
 * 				class
 * 				{
 * 					선언만 가능 : 변수 선언, 메소드 선언 => 메소드 호출, 연산자 처리, 제어문 사용(X) => 구현
 * 				}
 * 				method
 * 				{
 * 					선언(지역변수), 메소드 호출, 연산 처리, 제어문 => 구현
 * 					=> 사용자 요청 => 처리 => 결과값 전송 		
 * 				}
 * 				*** 메소드 => 생성자, 초기화 블록 => 구현
 * 					사용자 정의로 생성한 메소드, 생성자는 반드시 호출을 해야 함(자동 호출 X)
 * 				 	유일하게 초기화 블록만 자동 호출이 되나 1번만 수행함 
 * 				=> CRUD => 회원 가입 / 회원 정보 / 회원 수정 / 회원 탈퇴 => 게시판 제작
 * 		2) 메모리 저장
 * 		3) 활용(호출)
 * 
 * 	3. 클래스 종류
 * 		1) 일반 클래스
 *  	2) 추상 클래스
 *  	3) 인터페이스
 *  	4) 내부 클래스
 *  		- 멤버 클래스
 *  			예) class A
 *  				{
 *  					class B // 클래스 안에 클래스가 들어올 수 있음
 *  					{
 *  					}
 *  				}
 *  		- 지역 클래스
 *  			예) class A
 *  				{
 *  					public void disp()
 *  					{
 *  						class B
 *  						{
 *  						}
 *  					}
 *  				}
 *  				=> 상속 없이 오버라이딩
 *  		- 익명 클래스
 *  			예) class A
 *  				{
 *  					B b=new B()
 *  					{
 *  						메소드 추가
 *  						메소드 변경
 *  					}
 *  				}
 *  	5) 종단 클래스
 *  		final class => String, Math, System...
 *  
 * 	4. 비정상 종료 방지(=예외 처리)
 * 
 * 						
 */

public class MainClass {

	int a=100;
	static int b=200;
	
	public static void aaa()
	{
		MainClass m=new MainClass();
		System.out.println(m.a); // 인스턴스는 반드시 객체 생성 후 사용 가능
		System.out.println(b);
	}
	
	public static void main(String[] args) {
		
	}
	
}
