
/*
 * 	118 Page
 * 	웹(프로그램 X) 개발에 필요한 자바 문법/형식/흐름
 * 	브라우저(웹) <== 자바 ==> 오라클(웹에 필요한 데이터 저장)
 * 		└ HTML/JavaScript/CSS => 오라클/MySQL(데이터베이스)를 연결할 수 있는 프로그램이 없음
 * 	 	1. 클래스 구조
 * 			1) 형식
 * 				
 * 				class 클래스명
 * 				{
 * 					① 변수
 * 					② 생성자/초기화 블록
 * 					③ (멤버)메소드		
 * 				}
 * 				=> 가독성을 위해 해당 형식을 권장함
 * 				- class : 필요한 모든 데이터를 모아서(데이터 / 기능) 한 번에 저장 목적
 * 				- 클래스명 : 식별자(키워드가 아님)
 * 					· 알파벳 사용 권장
 * 					· 첫 글자는 대문자로 시작
 * 					· 맨 앞에 언더바(_)가 붙어 있을 경우 임시 클래스명
 * 					* 실무
 * 						데이터형 : ~VO, ~DTO
 * 						액션(기능) : ~DAO(데이터베이스), ~Manager, ~Service
 * 				- 변수(멤버변수, 공유변수) : 자동 default 초기화
 * 					· 멤버변수 : new를 사용해 객체 생성 시 메모리가 따로 저장됨
 * 						* 형식 : 객체명.변수명
 * 						* 저장 위치 : Heap(프로그래머 관리 영역) => GC(가비지컬렉션) 사용 대상 : 객체가 null이거나 사용하지 않는 객체
 * 															----------	
 * 														 => 멀티미디어 => System.gc()
 * 						* 사용 범위 : 해당 클래스 전체 => 필요 시에는 다른 클래스에서도 사용 가능
 * 						* 소멸 시기 : 프로그램 종료 시까지
 * 	
 * 					· 공유변수 : static이 앞에 붙어 있는 형태로 컴파일러에 의해 자동으로 메모리가 할당됨
 * 						* 형식1 : 객체명.변수명
 * 						* 형식2 : 클래스명.변수명
 * 						* 저장 위치 : Method Area(static) => 1개만 저장 가능
 * 						* 사용 범위 : 해당 클래스 전체 => 필요 시에는 다른 클래스에서도 사용 가능
 * 						* 소멸 시기 : 프로그램 종료 시까지
 * 					=> 각각 따로 저장할 것인지? 인스턴스 변수(90%)
 * 					=> 1개를 저장할 것인지? static
 * 					*** static 변수를 사용해야할 때 : 데이터 목록, 회원 목록, 게시물 목록 => 접속하는 모든 사람이 공유 가능(오라클)
 * 					
 * 				- 생성자 : 반드시 필요로 함(생성자가 없는 경우 자동으로 컴파일러가 생성)
 * 					· 멤버 변수 초기화
 * 					· 메모리 할당 => 호출됨
 * 					· 시작과 동시에 처리하는 명령문(오라클 연결, 네트워크 => 서버 구동, 자동 로그인)
 * 					· 특징
 * 						클래스명과 동일
 * 						리턴형이 없음
 * 						여러 개 생성 가능(오버로딩) => 중복 함수 정의
 * 						*** 오버로딩 조건
 * 							① 1개의 클래스에서 제작
 * 							② 메소드명이 동일
 * 							③ 매개변수의 개수나 데이터형이 다름 => 다른 메소드로 인식
 * 							④ 리턴형은 관계없음
 * 						*** 다른 클래스에서 객체 생성 시 반드시 공유해야 함
 * 				- 초기화 블록 : 초기값 담당
 * 					· 인스턴스 블록 : 인스턴스 변수, static 변수에 대한 초기화 가능
 * 					· static 블록 : static 변수만 초기화 가능
 * 
 * 					* 형식
 * 						class ClassName
 * 						{
 * 							변수 선언;
 * 							{
 * 								인스턴스 블록
 * 							}
 * 							
 * 							static
 * 							{
 * 								static 블록
 * 							}
 * 							---------------> 자동 호출, 상속 불가
 * 							*** 상속 예외 조건 : 생성자
 * 						}
 * 						=> 초기화 순서
 * 							① 명시적인 초기화 => 고민
 * 							② 초기화 블록 : static 변수에 대한 초기화
 * 										----------> 자동 저장
 * 										MyBatis => XML(파싱)
 * 								=> React(XML, JSON)
 * 							③ 생성자 : 인스턴스 변수
 * 							예) A a=new A()
 * 									new => int malloc(sizeof(A)) => 사용이 많음(연산자 승격)
 * 										=> 기본형외의 데이터형은 크기를 알지 못함
 * 										=> 리턴형 => 메모리 주소
 * 									A() => 변수의 초기값을 설정
 * 									*** 생성자는 단독 호출 불가 => new 생성자()
 * 				- 멤버 메소드 : 클래스 영역에서만 선언/구현
 * 					*** 객체 지향 3대 특성
 * 						① 캡슐화 : 읽기(getter) / 쓰기(setter)
 * 						② 이미 만들어진 메소드 => 변경 => 오버라이딩
 * 						③ 다형성 : 새로운 기능 추가 => 오버로딩
 * 						④ 상속 / 포함 : 재사용 => is-a / has-a
 * 					· 사용자 정의 메소드 => 기능, 반복 제거
 * 						* 멤버 메소드 : new를 사용할 때마다 따로 저장 => 다른 클래스와 통신할 때 주로 사용(메세지)
 * 							⊙ 형식 : [접근 지정어(주로 public 사용)] 리턴형 메소드명(매개변수목록) : 선언부
 * 									{
 * 										구현부
 * 									}
 * 							⊙ 호출 : 객체명.메소드명()
 * 								예) scan.nextInt()
 * 									s.trim()
 * 							⊙ 리턴형 : 사용자 요청에 대한 결과값 => 1개만 설정 가능
 * 								=> 상세보기 => 클래스 <배열(개수 고정) : 목록> => 컬렉션(가변)
 * 								=> 리턴형 반드시 사용
 * 									결과값이 있는 경우 : return 값
 * 									결과값이 없는 경우 : void => return 생략이 가능
 * 							⊙ 매개변수 : 사용자가 전달한 값
 * 								예) 로그인창 => id, pwd
 * 									검색기 => 검색어
 * 									클릭 => 번호
 * 									----------
 * 									게시판 글쓰기
 * 									회원가입
 * 									----------
 * 									클래스(3개 이상)
 * 							*** 멤버 메소드는 멤버 변수, static 변수, 지역 변수 모두 사용 가능
 * 							⊙ 메소드 유형
 * 								리턴형	매개변수
 * 									=> R(Select) => DML()
 * 								 O		  O
 * 								 O		  X
 * 								---------------> 메소드 자체 처리(CRUD)
 * 								=> CUD => (Insert, Update, Delete)
 * 								 X(void)  O
 * 								 X		  X
 * 								---------------> 웹에서는 리턴형이 많을 수 있음
 * 								
 * 				 			사용법 예)
 * 								class A
 * 								{
 * 									int a=10;
 * 									void aaa()
 * 									{
 * 										구현
 * 										return;
 * 									}
 * 									int bbb()
 * 									{
 * 										구현
 * 										return a; => 데이터형이 동일
 * 									}
 * 								}
 * 								
 * 								// 메모리 저장
 * 								A aa=new A();
 * 								
 * 							리턴형이 있는 경우
 * 								int a=aa.aaa();
 * 							리턴형이 없는 경우
 * 								aa.bbb();								
 * 
 * 						* 공유 메소드 : static
 * 							형식 : 
 * 								// 형식1
 * 								[접근 지정어] static 리턴형 메소드명(매개변수목록)
 * 								{
 * 									
 * 								}
 * 
 * 								// 형식2
 * 								static [접근 지정어] 리턴형 메소드명(매개변수목록)
 * 								{
 * 									
 * 								}
 * 								=> static 메소드는 static 변수, static 메소드 사용이 자유로움
 * 								=> static 메소드 안에서 인스턴스 변수, 메소드는 반드시 객체 생성 후 사용 가능
 * 
 * 						* 상속 방지 : final(종단 메소드)
 * 						* 선언만 함 : 구현은 프로그램에 맞게 => abstract
 * 						=> 버튼 클릭 => 설계(추상클래스 / 인터페이스)
 * 													-----
 * 					· 라이브러리 메소드
 * 						*** 라이브러리 VS 프레임워크
 * 							------	   ------
 * 							완제품(jar)  레고(java) => 전자 정부, ANY
 * 			2) 메모리 저장
 * 				- 객체 생성
 * 					· 기본형 : 변수
 * 					· 클래스 : 객체(메모리 공간)
 * 					* 하둡
 * 					* 클라우드
 * 					
 * 					· 형식 : new 생성자()
 * 						class A
 * 						{
 * 							
 * 						}
 * 						
 * 
 * 					· 호출
 * 						// 방법1
 * 						new A() => Thread() => new Thread(), new 윈도우()
 * 						=> 메모리 주소 리턴 => 필요한 경우에 주소 저장
 * 
 * 						// 방법2
 * 						A a=new A();
 * 				- 객체 사용
 * 					예)
 * 						A a=new A();
 * 						a.변수,메소드
 * 
 * 						A a;
 * 						a=new A();
 * 			3) 호출
 * 
 * 
 */

class A
{
	int a=10;
	static int b=20; // 메모리에 저장 완료
	
	void aaa(/* this */) // this 포함중(중복인 경우가 아니라면 생략 가능)
	{
		System.out.println(a);
		System.out.println(b);
	}
	static void bbb()
	{
		A aa=new A();
		System.out.println(aa.a);
		System.out.println(b);
	}
	void display()
	{
		System.out.println("A: display Call...");
	}
	void aaaa()
	{
		System.out.println("A: aaaa Call");
	}
}


public class MainClass {
	
	public static void main(String[] args) {
		
		A aa=new A(); // aa라는 메모리에 A변수 저장
		System.out.println(aa.a); // 객체명으로 접근
		System.out.println(aa.b);
		System.out.println(A.b); // 클래스명으로 접근
		
		new A().display();
		new A().aaaa();
		
		A a=new A();
		a.display();
		a.aaaa();
		
	}
}
